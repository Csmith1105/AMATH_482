%% Homework 1

% Using ultrasound, data is obtained concerning the spatial 
% variations in a small area of the intestines where the marble 
% is suspected to be. Unfortunately, the internal fluid movement 
% through the intestines generates highly noisy data.
% Locate and compute the trajectory of the marble. 

clear all; close all; clc;

% whos -file Testdata.mat
% returns the name, dimensions, size, and  
% data type of all variables in the MAT-file

load Testdata;

L = 15; % spatial domain
n = 64; % Fourier modes, i.e. # of points in spatial range (2^6)

% 1x65 vector, includes upper & lower bounds of spatial range [-15,15]
% what is the purpose of this vector
x2 = linspace(-L,L,n+1); 

x = x2(1:n); % x-coord of each point in the discretized spatial range [-15,15)
y = x;  % y-coord of each point in the discretized spatial range [-15,15)
z = x;  % z-coord of each point in the discretized spatial range [-15,15)

% wavenumbers (eigenvalues)
% 1x64 vector [[0,6.4926], [-6.7021, -0.2094]]
% goes from 0 to highest, then from lowest to 0
% scaling is 2pi/L  (why is code this 2pi/2L?)
k= (2*pi/(2*L))*[0:(n/2-1) -n/2:-1];

% 1x64 vector [-6.7021, 6.4926]
% goes from lowest to highest
ks=fftshift(k);

% grid with spatial coordinates
[X,Y,Z] = meshgrid(x,y,z);

% grid with frequency values
[Kx,Ky,Kz] = meshgrid(ks,ks,ks);

%% 1
% Through averaging of the spectrum, determine the frequency signature 
%(center frequency) generated by the marble.

Un = zeros(n,n,n,20);  % for storing the reshaped original Un data
Un_fft = zeros(n,n,n,20); % for storing the transformed data
sum_fft = zeros(n,n,n); % for storing the cumulative sum of values of transformed data

for j=1:20  % because we have 20 rows
   % Creates a 3D grid for each observation in Undata
   % this is the value of our function at each 
   % discretized point in space
    Un(:,:,:,j) = reshape(Undata(j,:),n,n,n); % stores the grid data 
  
    % transform the grid data to the frequency domain
    Un_fft(:,:,:,j) = fftn(Un(:,:,:,j));
   
    % uses the function values to transform to signal data
   % cumulative sum of signal values at each point in the grid
    sum_fft = sum_fft + Un_fft(:,:,:,j);
   
    % close all, isosurface(X,Y,Z,abs(Un(:,:,:,j)),0.4)
   % axis([-20 20 -20 20 -20 20]), grid on, drawnow
   % pause(2)
end

% adjust this so that it corresponds to the indices
% of the Kx,Ky,Kz matrices, then take absolute value
% because we are interested in magnitude

mean_fft = abs(sum_fft)/20;  
% mean_fft = abs(fftshift(mean_fft))/20;  

% find the max value and indices of the max value in the grid

% returns the linear index corresponding to the max value in mean_fft
[max_signal, max_idx] = max(mean_fft(:));

% converts the linear index to corresponding x, y, z indices
% with fftshift of mean_fft (28, 42, 33)
% without fftshift of mean_fft (60, 10, 1)
[max_x, max_y, max_z] = ind2sub(size(mean_fft), max_idx);

% using the max coordinates, find frequencies associated with max signal
% with fftshift (1.8850, -1.0472, 0)
% without fftshift (-4.8171, 5.6549, -6.7021), mean filtered (-4.8171, 5.6549, -6.7021)
kx_center = Kx(max_x, max_y, max_z); 
ky_center = Ky(max_x, max_y, max_z); 
kz_center = Kz(max_x, max_y, max_z); 

%% 2
% Filter the data around the center frequency determined above in 
% order to denoise the data and determine the path of the marble. 
% (use plot3 to plot the path once you have it)

% Since we have three different frequencies (in x, y, and z direction)
% for each point in the grid, we use the formula
% exp(-0.2*((kx - kx_0).^2 + (ky - ky_0).^2 + (kz - kz_0).^2); 
% where 0.2 is the tau value which is the width of our filter
% has something to do with the Heisenberg Uncertainty Principle?
% I think the wider our filter, the more accurate the 
% signal in the time domain will be

filter = exp(-0.2*((Kx(:,:,:) - kx_center).^2 ... 
    + (Ky(:,:,:) - ky_center).^2 ... 
    + (Kz(:,:,:) - kz_center).^2)); 

% filter=exp(-0.2*(k).^2); 
% unft=filter.*unt; 
% unf=ifft(unft);


% now multiply the fiter value grid and the unfiltered data grid

Un_fft_filtered = zeros(n,n,n,20);

for j=1:20  
   Un_fft_filtered(:,:,:,j) = fftshift(filter).*fftshift(Un_fft(:,:,:,j));
    
   % FIGURE OUT HOW TO GET COORDS OF MAX VALUE
   % returns the max signal value in the spatial domain and 
   % the corresponding linear index 
   % [max_spatial_signal, max_idx] = max(max(max(Un_filtered(:,:,:,j))));
   % converts the linear index to corresponding x, y, z indices
   % [max_x, max_y, max_z] = ind2sub(size(Un_filtered(:,:,:,j)), max_spatial_signal);
   
   % plot the signal data in the frequency domain
   % close all, isosurface(Kx,Ky,Kz,abs(Un_fft_filtered(:,:,:,j)),0.4)
   % title("Signal in Frequency Domain", 'Fontsize',18)
   % axis([-10 10 -10 10 -10 10]), grid on, drawnow
   % pause(5)
end

%% Double checking the center frequencies
% After filtering data can you do the same averaging procedure and 
% obtain the same center frequency as you found previously?

sum_fft_check = zeros(n,n,n);

for j=1:20 
    
    % add all the filtered frequency data together
    sum_fft_check = sum_fft_check + fftshift(Un_fft_filtered(:,:,:,j));
end

% adjust this so that it corresponds to the indices
% of the Kx,Ky,Kz matrices, then take absolute value
% because we are interested in magnitude

% gives the mean of the freq data at each point
mean_fft_check = abs(sum_fft_check)/20;  

% find the indices of the maximum value in the grid

% returns the linear index corresponding to the max value in mean_fft
[max_val_check, max_idx_check] = max(mean_fft_check(:));

% converts the linear index to corresponding x, y, z indices
% with fftshift (28, 42, 33)
% without fftshift (60, 10, 1)
[max_x_check, max_y_check, max_z_check] = ind2sub(size(mean_fft_check), max_idx_check);

% using the max coordinates, find frequencies associated with max signal
% with fftshift (1.8850, -1.0472, 0)
kx_center_check = Kx(max_x_check, max_y_check, max_z_check); 
ky_center_check = Ky(max_x_check, max_y_check, max_z_check); 
kz_center_check = Kz(max_x_check, max_y_check, max_z_check);

%% Inverse FFT on the filtered f-domain data and then plot in spatial domain

Un_filtered = zeros(n,n,n, 20);  % stores filter data (spatial domain)
sum_un_filtered = zeros(n,n,n);

for j=1:20 
    Un_fft_filtered(:,:,:,j) = ifftshift(Un_fft_filtered(:,:,:,j));
    Un_filtered(:,:,:,j) = ifftn(Un_fft_filtered(:,:,:,j));
    sum_un_filtered = sum_un_filtered + Un_filtered(:,:,:,j);
    
   % FIGURE OUT HOW TO GET COORDS OF MAX VALUE
   % returns the max signal value in the spatial domain and 
   % the corresponding linear index 
   % [max_spatial_signal, max_idx] = max(max(max(Un_filtered(:,:,:,j))));
   % converts the linear index to corresponding x, y, z indices
   % [max_x, max_y, max_z] = ind2sub(size(Un_filtered(:,:,:,j)), max_spatial_signal);
   
   % plot the signal data in the spatial domain
%    close all, isosurface(X,Y,Z,abs(Un_filtered(:,:,:,j)),0.0)
%    title("Signal in Spatial Domain", 'Fontsize',18)
%    axis([-20 20 -20 20 -20 20]), grid on, drawnow
%    pause(5)
end

Un_filtered_1 = abs(Un_filtered(:,:,:,j));

sum_un_filtered = abs(sum_un_filtered(:));
mean_un_filtered = mean(sum_un_filtered) % 0.1352


%% 3
% Where should an intense acoustic wave be focused 
% to breakup the marble at the 20th data measurement?

% when we get back the signal data in the spatial domain, find
% spatial coordinates of the max signal data?
